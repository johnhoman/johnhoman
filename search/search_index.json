{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About me","title":"About me"},{"location":"#about-me","text":"","title":"About me"},{"location":"kubeflow-eks-deployment/","text":"Deployment on EKS eksctl create cluster --profile jackhoman.com -f - <<EOF EOF","title":"Deployment on EKS"},{"location":"kubeflow-eks-deployment/#deployment-on-eks","text":"eksctl create cluster --profile jackhoman.com -f - <<EOF EOF","title":"Deployment on EKS"},{"location":"kubeflow-profile-controller-iam-plugin/","text":"Kubeflow's IAM Plugin The following describes how to setup the profile controllers IAM plugin. For those who don't know what the profile controller is, I'll give a brief description below , but as a high level summation, the profile controller IAM plugin helps to establish trust relationships between a service account (pod identity) on an EKS cluster and any number of protected resources in AWS Profile Controller Kubeflow is designed in such a way that each user is provided their own namespace. During user onboarding a custom resource called a Profile is created for the user. This profile is created by a service called KFAM and managed by the profile controller. The profile controller manages several other resources as well, some of which are Namespace RoleBinding ServiceAccount default-viewer - namespace read default-editor - namespace write AuthorizationPolicy For now we're going to ignore most of those things and focus on the service account. A ServiceAccount in [Kubernetes] is a way for a pod to authenticate with the Kubernetes api server. It can be used for various other things (secret allowlisting, image pull secret injection, ..., etc). EKS uses a service account as a trusted identity to access other AWS resources such as s3 . Annotating the ServiceAccount You can either create a new service account with an annotation or use an existing one provided by Kubeflow . For now I'll annotate the default user for the example installation . kubectl annotate sa/default-editor -n kubernetes-user-example-com eks.amazonaws.com/role-arn = arn:aws:iam::0123456789012:role/kubernetes-user TODO: Finish","title":"Kubeflow's IAM Plugin"},{"location":"kubeflow-profile-controller-iam-plugin/#kubeflows-iam-plugin","text":"The following describes how to setup the profile controllers IAM plugin. For those who don't know what the profile controller is, I'll give a brief description below , but as a high level summation, the profile controller IAM plugin helps to establish trust relationships between a service account (pod identity) on an EKS cluster and any number of protected resources in AWS","title":"Kubeflow's IAM Plugin"},{"location":"kubeflow-profile-controller-iam-plugin/#profile-controller","text":"Kubeflow is designed in such a way that each user is provided their own namespace. During user onboarding a custom resource called a Profile is created for the user. This profile is created by a service called KFAM and managed by the profile controller. The profile controller manages several other resources as well, some of which are Namespace RoleBinding ServiceAccount default-viewer - namespace read default-editor - namespace write AuthorizationPolicy For now we're going to ignore most of those things and focus on the service account. A ServiceAccount in [Kubernetes] is a way for a pod to authenticate with the Kubernetes api server. It can be used for various other things (secret allowlisting, image pull secret injection, ..., etc). EKS uses a service account as a trusted identity to access other AWS resources such as s3 .","title":"Profile Controller"},{"location":"kubeflow-profile-controller-iam-plugin/#annotating-the-serviceaccount","text":"You can either create a new service account with an annotation or use an existing one provided by Kubeflow . For now I'll annotate the default user for the example installation . kubectl annotate sa/default-editor -n kubernetes-user-example-com eks.amazonaws.com/role-arn = arn:aws:iam::0123456789012:role/kubernetes-user TODO: Finish","title":"Annotating the ServiceAccount"},{"location":"kubernetes-webhook-python/","text":"Writing a Kubernetes Webhook in Python What is a webhook? Note I'll only briefly describe what a webhook is in the context of this document below but for detailed information see the kubernetes documentation on Dynamic Admission Control A webhook is a way to validate and/or apply defaults to a resource manifest such as a pod. Setting up a webhook typically requires a web service (deployed on the cluster in the normal way) and some configuration to tell Kubernetes how to use the web service. These configurations are MutatingWebhookConfiguration ValidatingWebhookConfiguration You can think of a webhook as a man in the middle attack on your resource manifest on its way to etcd . graph LR A[kubectl apply ...]; B(Mutating Webhook); C(Validating Webhook); D[etcd]; E[API Server]; A --> E --> D; E --> |admission review| B; E --> |admission review| C; B --> |patch| E; C --> |allowed?| E; subgraph client A end subgraph cluster B C D E end The client with POST a resource manifest to the Kubernetes API server such as apiVersion : v1 kind : Pod metadata : name : http-server spec : containers : - name : http-server image : python:3.9-slim command : [ \"python\" , \"-m\" , \"http.server\" , \"8888\" ] ports : - name : http containerPort : 8888 Kubernetes will forward an admission review to all applicable webhooks. The webhooks will respond with either patches or allow/deny. Eventually Kubernetes will persist the resource. Mutating (Defaulting) Webhook A mutating webhook would apply defaults to a resource triggered by some event. Let's say we wanted to add the image pull secret registry-credentials to every pod created in the default namespace. Using a mutating webhook, we can turn this apiVersion : v1 kind : Pod metadata : name : http-server spec : containers : - name : http-server image : python:3.9-slim command : [ \"python\" , \"-m\" , \"http.server\" , \"8888\" ] ports : - name : http containerPort : 8888 into this apiVersion : v1 kind : Pod metadata : name : http-server spec : containers : - name : http-server image : python:3.9-slim command : [ \"python\" , \"-m\" , \"http.server\" , \"8888\" ] ports : - name : http containerPort : 8888 imagePullSecrets : - name : registry-credentials Validating Webhook A validating webhook doesn't make any changes to the manifest. Its only job is to assert on the validity of the resource. A common use case for this is validating a container image. If only images from a specific registry such as registry.example.com are allowed (e.g. corporate compliance requirements), then we can have the validating webhook reject all pods with references to from other registries. jhoman@pop-os:~$ kubectl run http-server --image = python:3.7 -- python -m http.server 8888 Error from server: admission webhook \"webhook.example.com\" denied the request: Invalid image. Images must come from registry.example.com jhoman@pop-os:~$ kubectl run http-server --image = registry.example.com /python:3.7 -- python -m http.server 8888 pod/http-server created Writing a Webhook Any of the Python web frameworks should work but fastapi is likely the easiest. There's a lot of good information in the docs so for anything specific probably start there. The following is a basic webhook endpoint that sets the image pull policy in all containers of a pod to Always is unset. You can read more about a container image pull policy here . Note In practice this is unnecessary. Kubernetes will choose a sensible default based on the image tag if imagePullPolicy isn't specified # main.py import copy from base64 import b64encode from fastapi import FastAPI from jsonpatch import JsonPatch app = FastAPI () @app . post ( \"/mutate-v1-pod\" ) def mutate_pod ( admission_review : dict ): pod = copy . deepcopy ( admission_review [ \"request\" ][ \"object\" ]) containers = pod [ \"spec\" ][ \"containers\" ] for k in range ( 0 , len ( containers )): containers [ k ] . setdefault ( \"imagePullPolicy\" , \"Always\" ) patch = JsonPatch . from_diff ( admission_review [ \"request\" ][ \"object\" ], pod ) admission_review [ \"response\" ] = { \"uid\" : admission_review [ \"request\" ][ \"uid\" ], \"patch\" : b64encode ( str ( patch ) . encode ()) . decode (), \"patchType\" : \"JSONPatch\" , } return admission_review Let's take a deeper look at what's going on here. # main.py import copy from base64 import b64encode from fastapi import FastAPI from jsonpatch import JsonPatch app = FastAPI () @app . post ( \"/mutate-v1-pod\" ) def mutate_pod ( admission_review : dict ): pod = copy . deepcopy ( admission_review [ \"request\" ][ \"object\" ]) containers = pod [ \"spec\" ][ \"containers\" ] for k in range ( 0 , len ( containers )): containers [ k ] . setdefault ( \"imagePullPolicy\" , \"Always\" ) patch = JsonPatch . from_diff ( admission_review [ \"request\" ][ \"object\" ], pod ) admission_review [ \"response\" ] = { \"uid\" : admission_review [ \"request\" ][ \"uid\" ], \"patch\" : b64encode ( str ( patch ) . encode ()) . decode (), \"patchType\" : \"JSONPatch\" , } return admission_review admission_review is the payload sent by the Kubernetes API server that contains the manifest contents. The manifest resides in admission_review [ \"request\" ][ \"object\" ] and in this example it contains a Pod . Note copy . deepcopy () is used to avoid mutating the original object. The original needs to be preserved to compute the json patch # main.py import copy from base64 import b64encode from fastapi import FastAPI from jsonpatch import JsonPatch app = FastAPI () @app . post ( \"/mutate-v1-pod\" ) def mutate_pod ( admission_review : dict ): pod = copy . deepcopy ( admission_review [ \"request\" ][ \"object\" ]) containers = pod [ \"spec\" ][ \"containers\" ] for k in range ( 0 , len ( containers )): containers [ k ] . setdefault ( \"imagePullPolicy\" , \"Always\" ) patch = JsonPatch . from_diff ( admission_review [ \"request\" ][ \"object\" ], pod ) admission_review [ \"response\" ] = { \"uid\" : admission_review [ \"request\" ][ \"uid\" ], \"patch\" : b64encode ( str ( patch ) . encode ()) . decode (), \"patchType\" : \"JSONPatch\" , } return admission_review Here the webhook is setting default values on the spec. It's important that a webhook doesn't override a user provided value and only sets a value this isn't already set in the manifest. If, for example, there was already an imagePullPolicy of IfNotPreset set on the Pod then it would be impolite to ignore it and potentially dangerous (existing values are probably set for reason). # main.py import copy from base64 import b64encode from fastapi import FastAPI from jsonpatch import JsonPatch app = FastAPI () @app . post ( \"/mutate-v1-pod\" ) def mutate_pod ( admission_review : dict ): pod = copy . deepcopy ( admission_review [ \"request\" ][ \"object\" ]) containers = pod [ \"spec\" ][ \"containers\" ] for k in range ( 0 , len ( containers )): containers [ k ] . setdefault ( \"imagePullPolicy\" , \"Always\" ) patch = JsonPatch . from_diff ( admission_review [ \"request\" ][ \"object\" ], pod ) admission_review [ \"response\" ] = { \"uid\" : admission_review [ \"request\" ][ \"uid\" ], \"patch\" : b64encode ( str ( patch ) . encode ()) . decode (), \"patchType\" : \"JSONPatch\" , } return admission_review The response is a base64 encoded json patch with the changes rather than the actual changed manifest. This is essentially signaling to Kubernetes that the only fields that you care about are the fields within the patch.","title":"Writing a Kubernetes Webhook in Python"},{"location":"kubernetes-webhook-python/#writing-a-kubernetes-webhook-in-python","text":"","title":"Writing a Kubernetes Webhook in Python"},{"location":"kubernetes-webhook-python/#what-is-a-webhook","text":"Note I'll only briefly describe what a webhook is in the context of this document below but for detailed information see the kubernetes documentation on Dynamic Admission Control A webhook is a way to validate and/or apply defaults to a resource manifest such as a pod. Setting up a webhook typically requires a web service (deployed on the cluster in the normal way) and some configuration to tell Kubernetes how to use the web service. These configurations are MutatingWebhookConfiguration ValidatingWebhookConfiguration You can think of a webhook as a man in the middle attack on your resource manifest on its way to etcd . graph LR A[kubectl apply ...]; B(Mutating Webhook); C(Validating Webhook); D[etcd]; E[API Server]; A --> E --> D; E --> |admission review| B; E --> |admission review| C; B --> |patch| E; C --> |allowed?| E; subgraph client A end subgraph cluster B C D E end The client with POST a resource manifest to the Kubernetes API server such as apiVersion : v1 kind : Pod metadata : name : http-server spec : containers : - name : http-server image : python:3.9-slim command : [ \"python\" , \"-m\" , \"http.server\" , \"8888\" ] ports : - name : http containerPort : 8888 Kubernetes will forward an admission review to all applicable webhooks. The webhooks will respond with either patches or allow/deny. Eventually Kubernetes will persist the resource.","title":"What is a webhook?"},{"location":"kubernetes-webhook-python/#mutating-defaulting-webhook","text":"A mutating webhook would apply defaults to a resource triggered by some event. Let's say we wanted to add the image pull secret registry-credentials to every pod created in the default namespace. Using a mutating webhook, we can turn this apiVersion : v1 kind : Pod metadata : name : http-server spec : containers : - name : http-server image : python:3.9-slim command : [ \"python\" , \"-m\" , \"http.server\" , \"8888\" ] ports : - name : http containerPort : 8888 into this apiVersion : v1 kind : Pod metadata : name : http-server spec : containers : - name : http-server image : python:3.9-slim command : [ \"python\" , \"-m\" , \"http.server\" , \"8888\" ] ports : - name : http containerPort : 8888 imagePullSecrets : - name : registry-credentials","title":"Mutating (Defaulting) Webhook"},{"location":"kubernetes-webhook-python/#validating-webhook","text":"A validating webhook doesn't make any changes to the manifest. Its only job is to assert on the validity of the resource. A common use case for this is validating a container image. If only images from a specific registry such as registry.example.com are allowed (e.g. corporate compliance requirements), then we can have the validating webhook reject all pods with references to from other registries. jhoman@pop-os:~$ kubectl run http-server --image = python:3.7 -- python -m http.server 8888 Error from server: admission webhook \"webhook.example.com\" denied the request: Invalid image. Images must come from registry.example.com jhoman@pop-os:~$ kubectl run http-server --image = registry.example.com /python:3.7 -- python -m http.server 8888 pod/http-server created","title":"Validating Webhook"},{"location":"kubernetes-webhook-python/#writing-a-webhook","text":"Any of the Python web frameworks should work but fastapi is likely the easiest. There's a lot of good information in the docs so for anything specific probably start there. The following is a basic webhook endpoint that sets the image pull policy in all containers of a pod to Always is unset. You can read more about a container image pull policy here . Note In practice this is unnecessary. Kubernetes will choose a sensible default based on the image tag if imagePullPolicy isn't specified # main.py import copy from base64 import b64encode from fastapi import FastAPI from jsonpatch import JsonPatch app = FastAPI () @app . post ( \"/mutate-v1-pod\" ) def mutate_pod ( admission_review : dict ): pod = copy . deepcopy ( admission_review [ \"request\" ][ \"object\" ]) containers = pod [ \"spec\" ][ \"containers\" ] for k in range ( 0 , len ( containers )): containers [ k ] . setdefault ( \"imagePullPolicy\" , \"Always\" ) patch = JsonPatch . from_diff ( admission_review [ \"request\" ][ \"object\" ], pod ) admission_review [ \"response\" ] = { \"uid\" : admission_review [ \"request\" ][ \"uid\" ], \"patch\" : b64encode ( str ( patch ) . encode ()) . decode (), \"patchType\" : \"JSONPatch\" , } return admission_review Let's take a deeper look at what's going on here. # main.py import copy from base64 import b64encode from fastapi import FastAPI from jsonpatch import JsonPatch app = FastAPI () @app . post ( \"/mutate-v1-pod\" ) def mutate_pod ( admission_review : dict ): pod = copy . deepcopy ( admission_review [ \"request\" ][ \"object\" ]) containers = pod [ \"spec\" ][ \"containers\" ] for k in range ( 0 , len ( containers )): containers [ k ] . setdefault ( \"imagePullPolicy\" , \"Always\" ) patch = JsonPatch . from_diff ( admission_review [ \"request\" ][ \"object\" ], pod ) admission_review [ \"response\" ] = { \"uid\" : admission_review [ \"request\" ][ \"uid\" ], \"patch\" : b64encode ( str ( patch ) . encode ()) . decode (), \"patchType\" : \"JSONPatch\" , } return admission_review admission_review is the payload sent by the Kubernetes API server that contains the manifest contents. The manifest resides in admission_review [ \"request\" ][ \"object\" ] and in this example it contains a Pod . Note copy . deepcopy () is used to avoid mutating the original object. The original needs to be preserved to compute the json patch # main.py import copy from base64 import b64encode from fastapi import FastAPI from jsonpatch import JsonPatch app = FastAPI () @app . post ( \"/mutate-v1-pod\" ) def mutate_pod ( admission_review : dict ): pod = copy . deepcopy ( admission_review [ \"request\" ][ \"object\" ]) containers = pod [ \"spec\" ][ \"containers\" ] for k in range ( 0 , len ( containers )): containers [ k ] . setdefault ( \"imagePullPolicy\" , \"Always\" ) patch = JsonPatch . from_diff ( admission_review [ \"request\" ][ \"object\" ], pod ) admission_review [ \"response\" ] = { \"uid\" : admission_review [ \"request\" ][ \"uid\" ], \"patch\" : b64encode ( str ( patch ) . encode ()) . decode (), \"patchType\" : \"JSONPatch\" , } return admission_review Here the webhook is setting default values on the spec. It's important that a webhook doesn't override a user provided value and only sets a value this isn't already set in the manifest. If, for example, there was already an imagePullPolicy of IfNotPreset set on the Pod then it would be impolite to ignore it and potentially dangerous (existing values are probably set for reason). # main.py import copy from base64 import b64encode from fastapi import FastAPI from jsonpatch import JsonPatch app = FastAPI () @app . post ( \"/mutate-v1-pod\" ) def mutate_pod ( admission_review : dict ): pod = copy . deepcopy ( admission_review [ \"request\" ][ \"object\" ]) containers = pod [ \"spec\" ][ \"containers\" ] for k in range ( 0 , len ( containers )): containers [ k ] . setdefault ( \"imagePullPolicy\" , \"Always\" ) patch = JsonPatch . from_diff ( admission_review [ \"request\" ][ \"object\" ], pod ) admission_review [ \"response\" ] = { \"uid\" : admission_review [ \"request\" ][ \"uid\" ], \"patch\" : b64encode ( str ( patch ) . encode ()) . decode (), \"patchType\" : \"JSONPatch\" , } return admission_review The response is a base64 encoded json patch with the changes rather than the actual changed manifest. This is essentially signaling to Kubernetes that the only fields that you care about are the fields within the patch.","title":"Writing a Webhook"}]}